# Part3: 중급
### 056. 출력되는 행 제한하기 (ROWNUM)
```
SELECT *
FROM TABLE
WHERE ROWNUM <= N;
```

### 057. 출력되는 행 제한하기2 (TOP-N QUERY)
```
SELECT *
FROM TABLE
ORDER BY COL1 FETCH FRIST N ROWS ONLY;
-- ORDER BY COL1 FETCH FRIST N PERCENT ROWS ONLY;
-- ORDER BY COL1 FETCH FRIST N ROWS WITH TIES;
-- ORDER BY COL1 OFFSET N ROWS FETCH FIRST N ROWS ONLY;
```

### 058. 여러 테이블의 데이터를 조인해서 출력하기 (EQUI JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A, TABLE2 B
WHERE A.COL3 = B.COL3;
```

### 059. 여러 테이블의 데이터를 조인해서 출력하기2 (NON EQUI JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A, TABLE2 B
WHERE A.COL3 (>, <, >=, <=, ...) B.COL3;
```

### 060. 여러 테이블의 데이터를 조인해서 출력하기3 (OUTER JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A, TABLE2 B
WHERE A.COL3 (+) = B.COL3;
```

### 061. 여러 테이블의 데이터를 조인해서 출력하기4 (SELF JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A, TABLE1 B
WHERE A.COL3 = B.COL4;
```

### 062. 여러 테이블의 데이터를 조인해서 출력하기5 (ON 조건)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A 
JOIN TABLE2 B ON A.COL3 = B.COL3
JOIN TABLE3 C ON A.COL4 BETWEEN C.COL1 AND C.COL2;
```

### 063. 여러 테이블의 데이터를 조인해서 출력하기6 (USING 조건)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A 
JOIN TABLE2 B USING (COL1);
```

### 064. 여러 테이블의 데이터를 조인해서 출력하기7 (NATURAL JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A 
NATURAL JOIN TABLE2 B;
```

### 065. 여러 테이블의 데이터를 조인해서 출력하기8 (LEFT/RIGHT OUTER JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A 
LEFT/RIGHT OUTER JOIN TABLE2 B ON A.COL3 = B.COL3;
```

### 066. 여러 테이블의 데이터를 조인해서 출력하기9 (FULL OUTER JOIN)
```
SELECT A.COL1, B.COL2
FROM TABLE1 A 
FULL OUTER JOIN TABLE2 B ON A.COL3 = B.COL3;
```
### 067. 집합 연산자로 데이터를 위아래로 연결하기 (UNION ALL)
```
SELECT COL1, COL2
FROM TABLE1
UNION ALL
SELECT COL3, COL4
FROM TABLE2;
```

### 068. 집합 연산자로 데이터를 위아래로 연결하기2 (UNION)
```
SELECT COL1, COL2
FROM TABLE1
UNION
SELECT COL3, COL4
FROM TABLE2;
```
### 069. 집합 연산자로 데이터의 교집합을 출력하기 (INTERSECT)
```
SELECT COL1, COL2
FROM TABLE1
INTERSECT
SELECT COL3, COL4
FROM TABLE2;
```
### 070. 집합 연산자로 데이터의 차집합을 출력하기 (MINUS)
```
SELECT COL1, COL2
FROM TABLE1
MINUS
SELECT COL3, COL4
FROM TABLE2;
```
### 071. 서브 쿼리 사용하기 (단일결과 서브쿼리)
```
SELECT COL1, COL2
FROM TABLE1
WHERE COL2 > (SELECT 집계함수(COL1) FROM TABLE2);
```
### 072. 서브 쿼리 사용하기2 (다중결과 서브쿼리)
```
SELECT COL1, COL2
FROM TABLE1
WHERE COL2 IN (SELECT COL1 FROM TABLE2);
```

### 073. 서브 쿼리 사용하기3 (NOT IN)
```
SELECT COL1, COL2
FROM TABLE1
WHERE COL2 NOT IN (SELECT COL1 FROM TABLE2 WHERE COL1 IS NOT NULL);
```

### 074. 서브 쿼리 사용하기4 (EXISTS, NOT EXISTS)
```
SELECT COL1, COL2
FROM TABLE1
WHERE EXISTS (SELECT * FROM TABLE2);
```

### 075. 서브 쿼리 사용하기5 (HAVING절)
```
SELECT COL1, 집계함수(COL2)
FROM TABLE1
GROUP BY COL1
HAVING 집계함수(COL2) > (SELECT ....);
```

### 076. 서브 쿼리 사용하기6 (FROM절)
```
SELECT A1
FROM (SELECT COL1 AS "A1" FROM TABLE1)
WHERE A1 ...;
```

### 077. 서브 쿼리 사용하기7 (SELECT절)
```
SELECT (SELECT COL1 FROM TABLE2)
FROM TABLE1;
```

### 078. 데이터 입력하기 (INSERT)
```
INSERT INTO TABLE(COL1, COL2, ...)
VALUES(값1, 값2, ...)
```

### 079. 데이터 수정하기 (UPDATE)
```
UPDATE TABLE1
SET COL1 = 값1
WHERE COL2 ...;
```

### 080. 데이터 삭제하기 (DELETE, TRUNCATE, DROP)
```
DELETE FROM TABLE1
WHERE COL1 ...;

TRUNCATE TABLE TABLE1;
DROP TABLE TABLE1;
```

### 081. 데이터 저장 및 취소하기 (COMMIT, ROLLBACK)

### 082. 데이터 입력, 수정, 삭제 한번에 하기 (MERGE)
```
MERGE INTO TABLE1 A
USING TABLE2 B ON (A.COL1 = B.COL1)
WHEN MATCHED THEN
UPDATE SET A.COL2 = B.COL2
WHEN UNMATCHED THEN
INSERT (A.COL2) VALUES(B.COL2);
```

### 083. 락(LOCK) 이해하기

### 084. SELECT FOR UPDATE절 이해하기

### 085. 서브 쿼리를 사용하여 데이터 입력하기
```
INSERT INTO TABLE1(COL1, COL2)
SELECT COL1, COL2
FROM TABLE2;
```

### 086. 서브 쿼리를 사용하여 데이터 수정하기
```
UPDATE TABLE1
SET (COL1, COL2) = (SELECT COL1, COL2 FROM TABLE2)
WHERE COL3 ...;
```

### 087. 서브 쿼리를 사용하여 데이터 삭제하기
```
DELETE FROM TABLE1
WHERE COL1 > (SELECT AVG(COL1) FROM TABLE2);
```

### 088. 서브 쿼리를 사용하여 데이터 합치기
```
MERGE INTO TABLE1 A
USING (SELECT COL1, SUM(COL2) FROM TABLE2 GROUP BY COL1) B ON (A.COL1 = B.COL1)
WHEN MATCHED THEN
UPDATE SET A.COL2 = B.COL2
WHEN UNMATCHED THEN
INSERT (A.COL2) VALUES(B.COL2);
```

### 089. 계층형 질의문으로 서열을 주고 데이터 출력하기 (START WITH CONNECT BY PRIOR)
```
SELECT COL1, LEVEL
FROM TABLE1
START WITH COL1 = 값1
CONNECT BY PRIOR COL2 = COL3;
```

### 090. 계층형 질의문으로 서열을 주고 데이터 출력하기2
```
SELECT COL1, LEVEL
FROM TABLE1
START WITH COL1 = 값1
CONNECT BY PRIOR COL2 = COL3 AND COL1 != 값2;
```

### 091. 계층형 질의문으로 서열을 주고 데이터 출력하기3 (SIBLINGS)
```
SELECT COL1, LEVEL, COL4
FROM TABLE1
START WITH COL1 = 값1
CONNECT BY PRIOR COL2 = COL3
ORDER SIBLINGS BY COL4;
```

### 092. 계층형 질의문으로 서열을 주고 데이터 출력하기4 (SYS_CONNECT_BY_PATH)
```
SELECT
SYS_CONNECT_BY_PATH(COL1, 구분자') AS PATH
FROM TABLE1
START WITH COL1 = 값1
CONNECT BY PRIOR COL2 = COL3;
```

### 093. 일반 테이블 생성하기 (CREATE TABLE)
```
CREATE TABLE TABLE1
(COL1   NUMBER(10,2)
 COL2   VARCHART(10)
 COL3   DATE);
```

### 094. 임시 테이블 생성하기 (CREATE TEMPORARY TABLE)
```
CREATE GLOBAL TEMPORARY TABLE TABLE1
(COL1   NUMBER(10,2)
 COL2   VARCHART(10)
 COL3   DATE);
```

### 095. 복잡한 쿼리를 단순하게 하기 (VIEW)
```
CREATE VIEW VIEW1 AS
    SELECT COL1, COL2
    FROM TABLE1;
```
### 096. 복잡한 쿼리를 단순하게 하기2 (VIEW)

### 097. 데이터 검색 속도를 높이기 (INDEX)
```
CREATE INDEX INDEX1
ON TABLE1(COL1);
```

### 098. 절대로 중복되지 않는 번호 만들기 (SEQUENCE)
```
CREATE SEQUENCE SEQUENCE1
START WITH N
INREMENT BY N
MAXVALUE N
NOCYCLE;
```

### 099. 실수로 지운 데이터 복구하기 (FLASHBACK QUERY)
```
SELECT COL1, COL2
FROM TABLE1
AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '5' MINUTE);
-- AS OF TIMESTAMP '21/04/19 17:40:00';
```

### 100. 실수로 지운 데이터 복구하기2 (FLASHBACK TABLE)
```
ALTER TABLE TABLE1 ENABLE ROW MOVEMENT;

FLASHBACK TABLE TABLE1
TO TIMESTAMP (SYSTIMESTAMP - INTERVAL '5' MINUTE);
-- TO TIMESTAMP TO_TIMESTAMP('21/04/19 17:40:00', 'RR/MM/DD HH24:MI:SS');
```

### 101. 실수로 지운 데이터 복구하기3 (FLASHBACK DROP)
```
FLASHBACK TABLE TABLE1
TO BEFORE DROP RENAME TO TABLE2;
```

### 102. 실수로 지운 데이터 복구하기4 (FLASHBACK VERSION QUERY)
```
SELECT COL1, VERSIONS_STARTTIME, VERSIONS_ENDTIME, VERSIONS_OPERATION
FROM TABLE1
VERSIONS BETWEEN TIMESTAMP
         TO_TIMESTAMP('2021-04-19 18:19:00', 'RRRR-MM-DD HH24:MI:SS')
         AND MAXVALUE
ORDER BY VERSIONS_STARTTIME;
```

### 103. 실수로 지운 데이터 복구하기5 (FLASHBACK TRANSACTION QUERY)
```
SELECT UNDO_SQL
FROM FLASHBACK_TRANSACTION_QUERY
WHERE TABLE_OWNER = 유저아이디 AND TABLE_NAME = TABLE1
AND COMMIT_SCN BETWENN N1 AND N2
ORDER BY START_TIMESTAMP DESC;
```

### 104. 데이터의 품질 높이기 (PRIMARY KEY)
```
CREATE TABLE1
(COL1    NUMBER(10) CONSTRAINT 제약이름 PRIMARY KEY);

ALTER TABLE1
ADD CONSTRAINT 제약이름 PRIMARY KEY(COL1);
```

### 105. 데이터의 품질 높이기2 (UNIQUE)
```
CREATE TABLE1
(COL1    NUMBER(10) CONSTRAINT 제약이름 UNIQUE);

ALTER TABLE1
ADD CONSTRAINT 제약이름 UNIQUE(COL1);
```

### 106. 데이터의 품질 높이기3 (NOT NULL)
```
CREATE TABLE1
(COL1    NUMBER(10) CONSTRAINT 제약이름 NOT NULL);

ALTER TABLE1
MODIFY COL1 CONSTRAINT 제약이름 NOT NULL;
```

### 107. 데이터의 품질 높이기4 (CHECK)
```
CREATE TABLE1
(COL1    NUMBER(10) CONSTRAINT 제약이름 CHECK (제약조건));
```

### 108. 데이터의 품질 높이기5 (FOREIGN KEY)
```
CREATE TABLE1
(COL1    NUMBER(10) CONSTRAINT 제약이름 REFERENCES TABLE2(COL2);
```

### 109. WITH절 사용하기 (WITH ~ AS)
```
WITH TEMP_TABLE1 AS (SELECT * FROM TABLE1)
    SELECT *
    FROM TEMP_TABLE1
    WHERE COL1 ...;
```

### 110. WITH절 사용하기2 (SUBQUERY FACTORING)
```
WITH TEMP_TABLE1 AS (SELECT * FROM TABLE1),
     TEMP_TABLE2 AS (SELECT * FROM TEMP_TABLE1)
    SELECT *
    FROM TABLE3
    WHERE COL1 ...;
```